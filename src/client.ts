// Code generated by goctl-sdk. DO NOT EDIT.

import type * as types from './types';

export interface ClientOptions {
  timeout?: number;
}

export class Outlet {
  private apiKey: string;
  private baseURL: string;
  private timeout: number;


  readonly emails: EmailsResource;
  readonly sequences: SequencesResource;
  readonly stats: StatsResource;
  readonly tracking: TrackingResource;
  readonly webhooks: WebhooksResource;
  readonly contacts: ContactsResource;
  readonly lists: ListsResource;

  /**
   * Create a new Outlet API client.
   * @param apiKey - Your API key
   * @param baseURL - Your Outlet instance URL (required - this is a self-hosted system)
   * @param options - Optional configuration
   */
  constructor(apiKey: string, baseURL: string, options: ClientOptions = {}) {
    if (!apiKey) throw new Error('API key is required');
    if (!baseURL) throw new Error('Base URL is required');
    this.apiKey = apiKey;
    this.baseURL = baseURL.replace(/\/$/, '');
    this.timeout = options.timeout ?? 30000;


    this.emails = new EmailsResource(this);
    this.sequences = new SequencesResource(this);
    this.stats = new StatsResource(this);
    this.tracking = new TrackingResource(this);
    this.webhooks = new WebhooksResource(this);
    this.contacts = new ContactsResource(this);
    this.lists = new ListsResource(this);
  }

  async request<T>(method: string, path: string, body?: unknown, query?: Record<string, string>): Promise<T> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      let url = `${this.baseURL}${path}`;
      if (query) {
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(query)) {
          if (value !== undefined && value !== null) {
            params.append(key, String(value));
          }
        }
        const queryString = params.toString();
        if (queryString) url += `?${queryString}`;
      }

      const response = await fetch(url, {
        method,
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorBody = await response.json().catch(() => ({})) as { message?: string };
        throw new Error(errorBody.message || `HTTP ${response.status}`);
      }

      if (response.status === 204) return undefined as unknown as T;
      return response.json() as Promise<T>;
    } catch (err) {
      clearTimeout(timeoutId);
      throw err;
    }
  }
}


class EmailsResource {
  constructor(private client: Outlet) {}


  /**
   * 
   */
  async sendEmail(request: types.SendEmailRequest): Promise<types.SendEmailResponse> {
    return this.client.request<types.SendEmailResponse>(
      'POST',
      '/sdk/v1/emails/',
      request
    );
  }

  /**
   * 
   */
  async getEmailStatus(messageId: string): Promise<types.EmailStatusResponse> {
    const path = `/sdk/v1/emails/${messageId}`;
    return this.client.request<types.EmailStatusResponse>(
      'GET',
      path
    );
  }

  /**
   * 
   */
  async listEmailEvents(messageId: string): Promise<types.ListEmailEventsResponse> {
    const path = `/sdk/v1/emails/${messageId}/events`;
    return this.client.request<types.ListEmailEventsResponse>(
      'GET',
      path
    );
  }

}


class SequencesResource {
  constructor(private client: Outlet) {}


  /**
   * 
   */
  async enrollInSequence(request: types.EnrollSequenceRequest): Promise<types.EnrollSequenceResponse> {
    return this.client.request<types.EnrollSequenceResponse>(
      'POST',
      '/sdk/v1/sequences/enroll',
      request
    );
  }

  /**
   * 
   */
  async getSequenceEnrollments(email: string, sequenceSlug?: string): Promise<types.ListSequenceEnrollmentsResponse> {
    const query: Record<string, string> = {};
    if (email !== undefined) query['email'] = String(email);
    if (sequenceSlug !== undefined) query['sequence_slug'] = String(sequenceSlug);
    return this.client.request<types.ListSequenceEnrollmentsResponse>(
      'GET',
      '/sdk/v1/sequences/enrollments',
      undefined,
      query
    );
  }

  /**
   * 
   */
  async pauseSequenceEnrollment(request: types.PauseSequenceRequest): Promise<types.Response> {
    return this.client.request<types.Response>(
      'POST',
      '/sdk/v1/sequences/pause',
      request
    );
  }

  /**
   * 
   */
  async resumeSequenceEnrollment(request: types.ResumeSequenceRequest): Promise<types.Response> {
    return this.client.request<types.Response>(
      'POST',
      '/sdk/v1/sequences/resume',
      request
    );
  }

  /**
   * 
   */
  async unenrollFromSequence(request: types.UnenrollSequenceRequest): Promise<types.Response> {
    return this.client.request<types.Response>(
      'POST',
      '/sdk/v1/sequences/unenroll',
      request
    );
  }

}


class StatsResource {
  constructor(private client: Outlet) {}


  /**
   * 
   */
  async getContactStats(startDate?: string, endDate?: string, groupBy?: string): Promise<types.GetContactStatsResponse> {
    const query: Record<string, string> = {};
    if (startDate !== undefined) query['start_date'] = String(startDate);
    if (endDate !== undefined) query['end_date'] = String(endDate);
    if (groupBy !== undefined) query['group_by'] = String(groupBy);
    return this.client.request<types.GetContactStatsResponse>(
      'GET',
      '/sdk/v1/stats/contacts',
      undefined,
      query
    );
  }

  /**
   * 
   */
  async getEmailStats(startDate?: string, endDate?: string, groupBy?: string): Promise<types.GetEmailStatsResponse> {
    const query: Record<string, string> = {};
    if (startDate !== undefined) query['start_date'] = String(startDate);
    if (endDate !== undefined) query['end_date'] = String(endDate);
    if (groupBy !== undefined) query['group_by'] = String(groupBy);
    return this.client.request<types.GetEmailStatsResponse>(
      'GET',
      '/sdk/v1/stats/emails',
      undefined,
      query
    );
  }

  /**
   * 
   */
  async getStatsOverview(startDate?: string, endDate?: string): Promise<types.StatsOverviewResponse> {
    const query: Record<string, string> = {};
    if (startDate !== undefined) query['start_date'] = String(startDate);
    if (endDate !== undefined) query['end_date'] = String(endDate);
    return this.client.request<types.StatsOverviewResponse>(
      'GET',
      '/sdk/v1/stats/overview',
      undefined,
      query
    );
  }

}


class TrackingResource {
  constructor(private client: Outlet) {}


  /**
   * 
   */
  async trackClick(request: types.TrackClickRequest): Promise<types.Response> {
    return this.client.request<types.Response>(
      'POST',
      '/sdk/v1/tracking/click',
      request
    );
  }

  /**
   * 
   */
  async trackConfirm(request: types.TrackConfirmRequest): Promise<types.TrackConfirmResponse> {
    return this.client.request<types.TrackConfirmResponse>(
      'POST',
      '/sdk/v1/tracking/confirm',
      request
    );
  }

  /**
   * 
   */
  async trackOpen(request: types.TrackOpenRequest): Promise<types.Response> {
    return this.client.request<types.Response>(
      'POST',
      '/sdk/v1/tracking/open',
      request
    );
  }

  /**
   * 
   */
  async trackUnsubscribe(request: types.TrackUnsubscribeRequest): Promise<types.Response> {
    return this.client.request<types.Response>(
      'POST',
      '/sdk/v1/tracking/unsubscribe',
      request
    );
  }

}


class WebhooksResource {
  constructor(private client: Outlet) {}


  /**
   * 
   */
  async registerWebhook(request: types.RegisterWebhookRequest): Promise<types.RegisterWebhookResponse> {
    return this.client.request<types.RegisterWebhookResponse>(
      'POST',
      '/sdk/v1/webhooks/',
      request
    );
  }

  /**
   * 
   */
  async listWebhooks(): Promise<types.ListWebhooksResponse> {
    return this.client.request<types.ListWebhooksResponse>(
      'GET',
      '/sdk/v1/webhooks/'
    );
  }

  /**
   * 
   */
  async getWebhook(id: string): Promise<types.WebhookInfo> {
    const path = `/sdk/v1/webhooks/${id}`;
    return this.client.request<types.WebhookInfo>(
      'GET',
      path
    );
  }

  /**
   * 
   */
  async updateWebhook(id: string, request: types.UpdateWebhookRequest): Promise<types.WebhookInfo> {
    const path = `/sdk/v1/webhooks/${id}`;
    return this.client.request<types.WebhookInfo>(
      'PUT',
      path,
      request
    );
  }

  /**
   * 
   */
  async deleteWebhook(id: string): Promise<types.Response> {
    const path = `/sdk/v1/webhooks/${id}`;
    return this.client.request<types.Response>(
      'DELETE',
      path
    );
  }

  /**
   * 
   */
  async listWebhookLogs(id: string, limit?: number): Promise<types.ListWebhookLogsResponse> {
    const path = `/sdk/v1/webhooks/${id}/logs`;
    const query: Record<string, string> = {};
    if (limit !== undefined) query['limit'] = String(limit);
    return this.client.request<types.ListWebhookLogsResponse>(
      'GET',
      path,
      undefined,
      query
    );
  }

  /**
   * 
   */
  async testWebhook(id: string): Promise<types.TestWebhookResponse> {
    const path = `/sdk/v1/webhooks/${id}/test`;
    return this.client.request<types.TestWebhookResponse>(
      'POST',
      path
    );
  }

}


class ContactsResource {
  constructor(private client: Outlet) {}


  /**
   * 
   */
  async createContact(request: types.ContactRequest): Promise<types.ContactResponse> {
    return this.client.request<types.ContactResponse>(
      'POST',
      '/sdk/v1/contacts',
      request
    );
  }

  /**
   * 
   */
  async getContact(id: string): Promise<types.SDKContactInfo> {
    const path = `/sdk/v1/contacts/${id}`;
    return this.client.request<types.SDKContactInfo>(
      'GET',
      path
    );
  }

  /**
   * 
   */
  async updateContact(id: string, request: types.UpdateContactRequest): Promise<types.SDKContactInfo> {
    const path = `/sdk/v1/contacts/${id}`;
    return this.client.request<types.SDKContactInfo>(
      'PUT',
      path,
      request
    );
  }

  /**
   * 
   */
  async listContactActivity(id: string, limit?: number): Promise<types.ListContactActivityResponse> {
    const path = `/sdk/v1/contacts/${id}/activity`;
    const query: Record<string, string> = {};
    if (limit !== undefined) query['limit'] = String(limit);
    return this.client.request<types.ListContactActivityResponse>(
      'GET',
      path,
      undefined,
      query
    );
  }

  /**
   * 
   */
  async addContactTags(id: string, request: types.AddContactTagsRequest): Promise<types.Response> {
    const path = `/sdk/v1/contacts/${id}/tags`;
    return this.client.request<types.Response>(
      'POST',
      path,
      request
    );
  }

  /**
   * 
   */
  async removeContactTags(id: string, request: types.RemoveContactTagsRequest): Promise<types.Response> {
    const path = `/sdk/v1/contacts/${id}/tags`;
    return this.client.request<types.Response>(
      'DELETE',
      path,
      request
    );
  }

  /**
   * 
   */
  async globalUnsubscribe(request: types.GlobalUnsubscribeRequest): Promise<types.Response> {
    return this.client.request<types.Response>(
      'POST',
      '/sdk/v1/contacts/unsubscribe',
      request
    );
  }

}


class ListsResource {
  constructor(private client: Outlet) {}


  /**
   * 
   */
  async subscribeToList(slug: string, request: types.SubscribeRequest): Promise<types.Response> {
    const path = `/sdk/v1/lists/${slug}/subscribe`;
    return this.client.request<types.Response>(
      'POST',
      path,
      request
    );
  }

  /**
   * 
   */
  async unsubscribeFromList(slug: string, request: types.SubscribeRequest): Promise<types.Response> {
    const path = `/sdk/v1/lists/${slug}/unsubscribe`;
    return this.client.request<types.Response>(
      'POST',
      path,
      request
    );
  }

}

